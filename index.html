=<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kaleidoscope with Image</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: black;
      touch-action: none;
      -ms-touch-action: none;
      overscroll-behavior: none;
    }
    canvas {
      display: block;
    }
    #saveButton, #uploadInput {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.8);
      border: none;
      padding: 10px 15px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 5px;
    }
    #uploadInput {
      top: 50px;
      left: 10px;
      padding: 5px;
    }
  </style>
</head>
<body>
<button id="saveButton">Save Image</button>
<input type="file" accept="image/*" id="uploadInput" />
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
  let scene = new THREE.Scene();
  let camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  let renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  let texture = new THREE.Texture();
  let uniforms = {
    iTime: { value: 0 },
    iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    iMouse: { value: new THREE.Vector2(0, 0) },
    zoom: { value: 1.0 },
    iTexture: { value: texture },
    spinOffset: { value: 0.0 }
  };

  let lastDist = null;
  let lastX = null;

  // Mouse interaction
  window.addEventListener('mousemove', e => {
    uniforms.iMouse.value.x = e.clientX;
    uniforms.iMouse.value.y = window.innerHeight - e.clientY;
  });

  window.addEventListener('mousedown', e => {
    lastX = e.clientX;
  });

  window.addEventListener('mouseup', () => {
    lastX = null;
  });

  window.addEventListener('mousemove', e => {
    if (e.buttons === 1 && lastX !== null) {
      const dx = e.clientX - lastX;
      uniforms.spinOffset.value += dx * 0.005; // adjust rotation speed sensitivity
      lastX = e.clientX;
    }
  });

  window.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      uniforms.iMouse.value.x = e.touches[0].clientX;
      uniforms.iMouse.value.y = window.innerHeight - e.touches[0].clientY;
      lastX = e.touches[0].clientX;
    }
  }, { passive: true });

  window.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && lastX !== null) {
      const dx = e.touches[0].clientX - lastX;
      uniforms.spinOffset.value += dx * 0.005;
      lastX = e.touches[0].clientX;
    }
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (lastDist !== null) {
        const zoomChange = dist / lastDist;
        uniforms.zoom.value *= zoomChange;
        uniforms.zoom.value = Math.max(0.5, Math.min(3.0, uniforms.zoom.value));
      }
      lastDist = dist;
    }
  }, { passive: false });

  window.addEventListener('touchend', e => {
    if (e.touches.length < 2) {
      lastDist = null;
      lastX = null;
    }
  });

  const fragmentShader = `
    precision mediump float;
    uniform float iTime;
    uniform vec2 iResolution;
    uniform vec2 iMouse;
    uniform float zoom;
    uniform sampler2D iTexture;
    uniform float spinOffset;

    void main() {
      vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / (iResolution.y * zoom);
      vec2 mouse = (iMouse - 0.5 * iResolution.xy) / (iResolution.y * zoom);

      float r = length(uv);
      float a = atan(uv.y, uv.x) + 0.6 * iTime + spinOffset; // faster spin + gesture offset

      float symmetry = 8.0;
      a = mod(a, 6.283185 / symmetry);
      a = abs(a - 3.141592 / symmetry);
      uv = vec2(cos(a), sin(a)) * r;

      vec2 texCoord = 0.5 + uv;
      vec4 col = texture2D(iTexture, texCoord);

      gl_FragColor = col;
    }
  `;

  let material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    fragmentShader: fragmentShader
  });

  let geometry = new THREE.PlaneGeometry(2, 2);
  let mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  function animate(time) {
    uniforms.iTime.value = time * 0.001;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.iResolution.value.x = window.innerWidth;
    uniforms.iResolution.value.y = window.innerHeight;
  });

  document.getElementById('uploadInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      texture.image = img;
      texture.needsUpdate = true;
    };
    img.src = URL.createObjectURL(file);
  });

  document.getElementById('saveButton').addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'kaleidoscope_snapshot.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();
  });
</script>
</body>
</html>
