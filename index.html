<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kaleidoscope with Controls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: black;
      touch-action: none;
      -ms-touch-action: none;
      overscroll-behavior: none;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    button, input[type="file"], select, input[type="range"] {
      background: rgba(255,255,255,0.8);
      border: none;
      padding: 10px 15px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 5px;
    }
    label {
      color: white;
      font-size: 14px;
      user-select: none;
    }
  </style>
</head>
<body>
<div id="controls">
  <select id="modeToggle">
    <option value="color">Color Mode</option>
    <option value="image">Image Mode</option>
  </select>
  <input type="file" accept="image/*" id="uploadInput" />
  <label for="symmetrySlider">Symmetry:</label>
  <input type="range" id="symmetrySlider" min="2" max="16" value="8" />
  <button id="saveButton">Save Image</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
  let scene = new THREE.Scene();
  let camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  let renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const fallbackTexture = new THREE.DataTexture(new Uint8Array([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat);
  fallbackTexture.needsUpdate = true;

  let texture = fallbackTexture;
  let mode = 'color';
  let spinAngle = 0;
  let spinSpeed = 0.6;
  let symmetryValue = 8;

  let uniforms = {
    iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    iMouse: { value: new THREE.Vector2(0, 0) },
    zoom: { value: 1.0 },
    iTexture: { value: texture },
    spinAngle: { value: 0.0 },
    iTime: { value: 0.0 },
    mode: { value: 0 },
    symmetry: { value: symmetryValue }
  };

  let lastDist = null;
  let lastX = null;

  window.addEventListener('mousedown', e => {
    lastX = e.clientX;
  });

  window.addEventListener('mouseup', () => {
    lastX = null;
  });

  window.addEventListener('mousemove', e => {
    uniforms.iMouse.value.x = e.clientX;
    uniforms.iMouse.value.y = window.innerHeight - e.clientY;
    if (e.buttons === 1 && lastX !== null) {
      const dx = e.clientX - lastX;
      spinSpeed += dx * 0.01;
      lastX = e.clientX;
    }
  });

  window.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      uniforms.iMouse.value.x = e.touches[0].clientX;
      uniforms.iMouse.value.y = window.innerHeight - e.touches[0].clientY;
      lastX = e.touches[0].clientX;
    }
  }, { passive: true });

  window.addEventListener('touchmove', e => {
    if (e.touches.length === 1 && lastX !== null) {
      const dx = e.touches[0].clientX - lastX;
      spinSpeed += dx * 0.05;
      lastX = e.touches[0].clientX;
    }
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (lastDist !== null) {
        const zoomChange = dist / lastDist;
        uniforms.zoom.value *= zoomChange;
        uniforms.zoom.value = Math.max(0.5, Math.min(3.0, uniforms.zoom.value));
      }
      lastDist = dist;
    }
  }, { passive: false });

  window.addEventListener('touchend', () => {
    lastDist = null;
    lastX = null;
  });

  const fragmentShader = `
    precision mediump float;
    uniform vec2 iResolution;
    uniform vec2 iMouse;
    uniform float zoom;
    uniform float spinAngle;
    uniform sampler2D iTexture;
    uniform float iTime;
    uniform int mode;
    uniform int symmetry;

    vec3 getColor(float val) {
      float r = 0.5 + 0.5 * cos(6.2831 * val + 0.0);
      float g = 0.5 + 0.5 * cos(6.2831 * val + 2.0);
      float b = 0.5 + 0.5 * cos(6.2831 * val + 4.0);
      return vec3(r, g, b);
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / (iResolution.y * zoom);
      float r = length(uv);
      float a = atan(uv.y, uv.x);
      float sym = float(symmetry);
      a = mod(a, 6.283185 / sym);
      a = abs(a - 3.141592 / sym);
      a += spinAngle;
      uv = vec2(cos(a), sin(a)) * r;

      if (mode == 0) {
        float val = sin(length(uv - iMouse / (iResolution.y * zoom)) * 10.0 - iTime);
        float colorVal = 0.5 + 0.5 * val;
        gl_FragColor = vec4(getColor(colorVal), 1.0);
      } else {
        vec2 texCoord = 0.5 + uv;
        vec4 col = texture2D(iTexture, texCoord);
        gl_FragColor = col;
      }
    }
  `;

  let material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    fragmentShader: fragmentShader
  });

  let geometry = new THREE.PlaneGeometry(2, 2);
  let mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);

  function animate(time) {
    uniforms.iTime.value = time * 0.001;
    spinAngle += spinSpeed * 0.016;
    uniforms.spinAngle.value = spinAngle;
    spinSpeed *= 0.98;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.iResolution.value.x = window.innerWidth;
    uniforms.iResolution.value.y = window.innerHeight;
  });

  document.getElementById('uploadInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      texture = new THREE.Texture(img);
      texture.needsUpdate = true;
      uniforms.iTexture.value = texture;
    };
    img.src = URL.createObjectURL(file);
  });

  document.getElementById('modeToggle').addEventListener('change', (e) => {
    mode = e.target.value;
    uniforms.mode.value = mode === 'image' ? 1 : 0;
  });

  document.getElementById('symmetrySlider').addEventListener('input', (e) => {
    symmetryValue = parseInt(e.target.value, 10);
    uniforms.symmetry.value = symmetryValue;
  });

  document.getElementById('saveButton').addEventListener('click', () => {
    renderer.render(scene, camera);
    const link = document.createElement('a');
    link.download = 'kaleidoscope_snapshot.png';
    link.href = renderer.domElement.toDataURL('image/png');
    link.click();
  });
</script>
</body>
</html>
